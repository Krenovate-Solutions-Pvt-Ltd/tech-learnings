{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tech Learnings","text":"<p>This documentation is based on the some learnings from the first project that is built on Sage 10 with the ReactJs and Tailwind.</p>"},{"location":"cpt-or-options-page/","title":"Custom Post Types v/s ACF Options Page","text":""},{"location":"cpt-or-options-page/#understanding-custom-post-types-and-acf-option-pages-in-wordpress","title":"Understanding Custom Post Types and ACF Option Pages in WordPress","text":"<p>WordPress is a powerful and flexible content management system that allows for extensive customization to meet various needs. Two of the most useful features for managing content in WordPress are Custom Post Types (CPTs) and Advanced Custom Fields (ACF) Option Pages. This document aims to provide a comprehensive guide on when to use CPTs and when to use ACF Option Pages, helping developers make informed decisions to structure their content effectively.</p>"},{"location":"cpt-or-options-page/#custom-post-types-cpts","title":"Custom Post Types (CPTs)","text":"<p>Custom Post Types (CPTs) extend WordPress beyond the default Posts and Pages. They enable the creation of custom content types that can have their own distinct features and behaviors.</p>"},{"location":"cpt-or-options-page/#implementation","title":"Implementation:","text":"<p>We can create a custom post type either via a custom code or by using Wordpress Plugins like Custom Post UI. In the Pro feature of ACF plugin we also have an option to create Custom Post Types. So, it's up to you by which plugin you want to go with if you have a pro license of ACF then I will suggest definetely go with the ACF and get rid of the extra plugin depandancy.</p> <p>The code implementation is also very straight forward. We have one WordPress method <code>register_post_type()</code> which registers/creates a custom post type. To read more about this function refer this doc Include the code given below in theme's function.php file.</p> <pre><code>function create_blog_post_type() {\n    register_post_type('blog',\n        array(\n            'labels' =&gt; array(\n                'name' =&gt; __('Blogs'),\n                'singular_name' =&gt; __('Blog')\n            ),\n            'public' =&gt; true,\n            'has_archive' =&gt; true,\n            'rewrite' =&gt; array('slug' =&gt; 'blogs'),\n        )\n    );\n}\nadd_action('init', 'create_blog_post_type');\n</code></pre> <p>This will create an custom post type in the admin dashboard and you can now create as many posts inside this custom post type(CPT). But now if we need to display the listing or content of these posts in UI we need to create templates and you can create custom templates for your CPT by adding template files like <code>single-blog.php</code> and <code>archive-blog.php</code> in your theme. <code>single-blog.php</code> is for the template file for displaying the UI for your blogs and <code>archive-blog.php</code> is the file to display the UI for listing or index page of blogs.</p> <p>Please Note: In both ways either plugin or custom code to create CPT we need to create these template files.</p>"},{"location":"cpt-or-options-page/#acf-option-pages","title":"ACF Option Pages","text":"<p>ACF Option Pages allow for the creation of global settings and content that are not tied to any specific post or page, providing a centralized place for site-wide configurations. It provide a single location for managing site-wide settings. They simplify the management of content that does not fit into the standard post/page structure.</p>"},{"location":"cpt-or-options-page/#implementation_1","title":"Implementation:","text":"<p>We can use the ACF function to create an option page. Add the code below in finctions.php file.</p> <pre><code>if (function_exists('acf_add_options_page')) {\n    acf_add_options_page(array(\n        'page_title'    =&gt; 'Theme General Settings',\n        'menu_title'    =&gt; 'Theme Settings',\n        'menu_slug'     =&gt; 'theme-general-settings',\n        'capability'    =&gt; 'edit_posts',\n        'redirect'      =&gt; false\n    ));\n}\n</code></pre> <p>This function will create a setting page in admin dashboard then you can assign custom fields to the option page by ACF plugin and to retrieve the data use get_field() in your theme templates like this</p> <pre><code>$footer_text = get_field('footer_text', 'option');\necho $footer_text;\n</code></pre> <p><code>footer_text</code> here is the custom field slug that you had created and assigned to the option page by ACF plugin.</p> <p>Please Note: In the latest pro versions of ACF Plugin the functionality to create an option page comes by default so you don't need to create it via code you can directly create it by the plugins dashboard. Please find the attachment for the reference.</p> <p></p> <p>Please Note: Creating option page in any way is only available in ACF pro plugin.</p>"},{"location":"image-alt-tag/","title":"Image Alt Tag","text":""},{"location":"image-alt-tag/#image-alt-tag-customization","title":"Image alt tag customization","text":"<p>This section is required for the good SEO performance. In this we need to make sure we should include the alt attribute on image tag in HTML as well as pass a relevant value to it. We can pass the values in both ways either statically or dynamically.</p> <p>To pass the value dynamically we first need to make sure there should be a custom field setup in the backend usinfg ACF Pro. While creating a custom field of image type we need to make sure that the output type of the field must be selected as Image Array. See the attachment below for reference.</p> <p></p> <p>After configuring the custom field correctly, It will return an array with the values like image_url, alt, title, description, etc. and then we can add these values to the image element like this:</p> <p>Javascript:</p> <pre><code>&lt;img src={ data.image.url }\n    alt={ data.image.alt }\n/&gt;\n</code></pre> <p>PHP:</p> <pre><code>&lt;img src={{ $data-&gt;image-&gt;url }}\n    alt={{ $data-&gt;image-&gt;alt }}\n/&gt;\n</code></pre> <p>[ Note: We can add dynamic values only for those image elements whose values are coming from the custom fields. Else we need to add one relevant value statically. ]</p>"},{"location":"image-optimization/","title":"Image Optimization","text":""},{"location":"image-optimization/#jpgjpeg-to-webp-conversion-by-using-plugin","title":"JPG/JPEG to Webp Conversion by using plugin","text":"<p>WebP images are lightweight and now compatible with almost all browsers. Therefore, it is better to use WebP images instead of JPGs/JPEGs. This will be very helpful in improving webpage performance and speed optimization.</p> <p>Now, the thing comes in mind that Do we need to manually convert all the jpgs/jpegs to WebP? The answer is no. There is a WordPress plugin that will do the job for you what you need to do is just install and activate the Modern Image Formats developed by WordPress Performance Team.</p> <p>As far as the plugin version 2.0.1 is released it gives you support for both WebP and AVIF image formats. You can select any in our case we are using WebP as AVIF is only supported in some latest versions of Chrome. So, there are cross browser compatibility isssue with AVIF format. If you want to read more about AVIF image format you can refer this doc.</p> <p>Here you can see the basic settings that we need in our case.</p> <p></p> <p>Please Note: This plugin only converts the images that will get uploaded to media after activating the plugin. For all the previously uploaded images you need to upload the images again. So, It's better to consider this plugin at the very initial stage of starting development.</p>"},{"location":"relative-urls/","title":"Relative URL's","text":""},{"location":"relative-urls/#base-url-setup-for-the-relative-urls","title":"Base URL setup for the relative URL\u2019s","text":"<p>While using only blade files it's quite easy to add a base URL as a WordPress site URL by using a method <code>get_site_url()</code>. But when we need to use react.js for frontend we can't directly use this method inside the react components as we are restricted to add the php code inside javascript files. So, here we have a workaround for this by using the following ways:</p> <ul> <li> <p>Pass site url as a HTML attribute from the react component containing HTML Element(div, section, etc.). We can use the main HTML element from the template file(app.blade.php) to set an atrribute. <code>&lt;main id=\"main\" class=\"main\" site-url=\"{{ get_site_url() }}\"&gt;</code></p> </li> <li> <p>Then we need to read the attribute value inside js file using <code>getAttribute()</code> method and store it inside a variable. We can create the variable inside App.js file so that it is accessible for all components. <code>const site_url = document.getElementById('main').getAttribute('site-url');</code></p> </li> <li> <p>Now, we can pass the variable to multiple components as a props and can use it to set a base URL for relative URL's. <code>&lt;MainMenu siteUrl={siteUrl} /&gt;</code></p> </li> </ul> <p>Moreover, Instead of passing it as prop to each component, Alternatively we can create one method in App.js and then we can import that method inside the component something like this:</p> <p>App.js</p> <pre><code>const baseURL = (urlString) =&gt; {\n  let site_url = null;\n  if (urlString.indexOf('http://') === 0 || urlString.indexOf('https://') === 0 \n  || urlString.indexOf('www') === 0 || urlString.indexOf('mailto') === 0 || \n  urlString.indexOf('tel') === 0) {\n    site_url = '';\n  } else {\n    site_url = document.getElementById('main').getAttribute('site-url');\n  }\n\n  return site_url+urlString;\n}\n</code></pre> <p>YourComponent.js</p> <pre><code>import baseUri from '@scripts/app';\nconst YourComponent = () =&gt; {\n    return(\n        &lt;&gt;\n            &lt;a href={baseUri('/example')}&gt;Your Component&lt;/a&gt;\n        &lt;/&gt;\n    )\n}\nexport default YourComponent\n</code></pre>"}]}